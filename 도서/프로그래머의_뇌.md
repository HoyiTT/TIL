# [프로그래머의 뇌](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C)

[프로그래머의 뇌](https://books.google.co.kr/books/about/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.html?id=U39lEAAAQBAJ&source=kp_book_description&redir_esc=y) 를 보고 정리한 내용입니다.

# [목차](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EB%AA%A9%EC%B0%A8)
* [1장 코딩중 겪는 혼란에 대한 이해](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#1%EC%9E%A5-%EC%BD%94%EB%94%A9-%EC%A4%91-%EA%B2%AA%EB%8A%94-%ED%98%BC%EB%9E%80%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4)
  * [코드가 초래하는 세 가지 종류의 혼란](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EC%BD%94%EB%93%9C%EA%B0%80-%EC%B4%88%EB%9E%98%ED%95%98%EB%8A%94-%EC%84%B8-%EA%B0%80%EC%A7%80-%EC%A2%85%EB%A5%98%EC%9D%98-%ED%98%BC%EB%9E%80)
  * [코딩에 영향을 주는 인지 과정](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EC%BD%94%EB%94%A9%EC%97%90-%EC%98%81%ED%96%A5%EC%9D%84-%EC%A3%BC%EB%8A%94-%EC%9D%B8%EC%A7%80-%EA%B3%BC%EC%A0%95)
  * [인지 과정들의 상호 작용](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EC%9D%B8%EC%A7%80-%EA%B3%BC%EC%A0%95%EB%93%A4%EC%9D%98-%EC%83%81%ED%98%B8-%EC%9E%91%EC%9A%A9)
* [2장 신속한 코드 분석](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#2%EC%9E%A5-%EC%8B%A0%EC%86%8D%ED%95%9C-%EC%BD%94%EB%93%9C-%EB%B6%84%EC%84%9D)
  * [코드를 신속하게 읽기](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%8B%A0%EC%86%8D%ED%95%98%EA%B2%8C-%EC%9D%BD%EA%B8%B0)
  * [기억의 크기 제한을 극복하기](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EA%B8%B0%EC%96%B5%EC%9D%98-%ED%81%AC%EA%B8%B0-%EC%A0%9C%ED%95%9C%EC%9D%84-%EA%B7%B9%EB%B3%B5%ED%95%98%EA%B8%B0)
  * [읽는 것보다 보는 것이 더 많다](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EC%9D%BD%EB%8A%94-%EA%B2%83%EB%B3%B4%EB%8B%A4-%EB%B3%B4%EB%8A%94-%EA%B2%83%EC%9D%B4-%EB%8D%94-%EB%A7%8E%EB%8B%A4)
* [3장 프로그래밍 문법 빠르게 배우기](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#3%EC%9E%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AC%B8%EB%B2%95-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EA%B8%B0)
  * [문법을 기억하기 위한 팁](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EB%AC%B8%EB%B2%95%EC%9D%84-%EA%B8%B0%EC%96%B5%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%ED%8C%81)
  * [플래시카드 사용해 문법 배우기](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%ED%94%8C%EB%9E%98%EC%8B%9C%EC%B9%B4%EB%93%9C-%EC%82%AC%EC%9A%A9%ED%95%B4-%EB%AC%B8%EB%B2%95-%EB%B0%B0%EC%9A%B0%EA%B8%B0)
  * [어떻게 하면 잊어버리지 않을 수 있을까](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%98%EB%A9%B4-%EC%9E%8A%EC%96%B4%EB%B2%84%EB%A6%AC%EC%A7%80-%EC%95%8A%EC%9D%84-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C)
  * [문법을 더 오랫동안 기억하기](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EB%AC%B8%EB%B2%95%EC%9D%84-%EB%8D%94-%EC%98%A4%EB%9E%AB%EB%8F%99%EC%95%88-%EA%B8%B0%EC%96%B5%ED%95%98%EA%B8%B0)
* [4장 복잡한 코드 읽는 방법](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#4%EC%9E%A5-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EC%BD%94%EB%93%9C-%EC%9D%BD%EB%8A%94-%EB%B0%A9%EB%B2%95)
  * [복잡한 코드를 이해하는 것이 왜 어려울까?](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EB%B3%B5%EC%9E%A1%ED%95%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%99%9C-%EC%96%B4%EB%A0%A4%EC%9A%B8%EA%B9%8C)
  * [인지 부하를 줄이기 위한 기법](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EC%9D%B8%EC%A7%80-%EB%B6%80%ED%95%98%EB%A5%BC-%EC%A4%84%EC%9D%B4%EA%B8%B0-%EC%9C%84%ED%95%9C-%EA%B8%B0%EB%B2%95)
  * [작업 기억 공간에 부하가 오면 쓸 수 있는 기억 보조 수단](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EC%9E%91%EC%97%85-%EA%B8%B0%EC%96%B5-%EA%B3%B5%EA%B0%84%EC%97%90-%EB%B6%80%ED%95%98%EA%B0%80-%EC%98%A4%EB%A9%B4-%EC%93%B8-%EC%88%98-%EC%9E%88%EB%8A%94-%EA%B8%B0%EC%96%B5-%EB%B3%B4%EC%A1%B0-%EC%88%98%EB%8B%A8)
* [5장 코드를 더 깊이 있게 이해하기](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#5%EC%9E%A5-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%8D%94-%EA%B9%8A%EC%9D%B4-%EC%9E%88%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)
  * ['변수 역할' 프레임워크](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EB%B3%80%EC%88%98-%EC%97%AD%ED%95%A0-%ED%94%84%EB%A0%88%EC%9E%84-%EC%9B%8C%ED%81%AC)
  * [역할과 패러다임](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EC%97%AD%ED%95%A0%EA%B3%BC-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84)
  * [프로그램에 대해 깊이있는 지식을 얻으려면](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%97%90-%EB%8C%80%ED%95%B4-%EA%B9%8A%EC%9D%B4-%EC%9E%88%EB%8A%94-%EC%A7%80%EC%8B%9D%EC%9D%84-%EC%96%BB%EC%9C%BC%EB%A0%A4%EB%A9%B4)
  * [텍스트를 읽는 것과 코드를 읽는 것은 유사하다](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9D%BD%EB%8A%94-%EA%B2%83%EA%B3%BC-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%BD%EB%8A%94-%EA%B2%83%EC%9D%80-%EC%9C%A0%EC%82%AC%ED%95%98%EB%8B%A4)
  * [코드 읽기에 적용해볼 수 있는 텍스트 이해 전략](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EC%BD%94%EB%93%9C-%EC%9D%BD%EA%B8%B0%EC%97%90-%EC%A0%81%EC%9A%A9%ED%95%B4%EB%B3%BC-%EC%88%98-%EC%9E%88%EB%8A%94-%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%9D%B4%ED%95%B4-%EC%A0%84%EB%9E%B5)
* [6장 코딩 문제 해결을 더 잘하려면](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#6%EC%9E%A5-%EC%BD%94%EB%94%A9-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EC%9D%84-%EB%8D%94-%EC%9E%98%ED%95%98%EB%A0%A4%EB%A9%B4)
  * [모델을 사용해서 코드에 대해 생각해보기](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EB%AA%A8%EB%8D%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%EC%BD%94%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EA%B8%B0)
  * [정신 모델](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EC%A0%95%EC%8B%A0-%EB%AA%A8%EB%8D%B8)
  * [개념적 기계](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EA%B0%9C%EB%85%90%EC%A0%81-%EA%B8%B0%EA%B3%84)
  * [개념적 기계와 언어](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EA%B0%9C%EB%85%90%EC%A0%81-%EA%B8%B0%EA%B3%84%EC%99%80-%EC%96%B8%EC%96%B4)
  * [개념적 기계와 스키마타](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EA%B0%9C%EB%85%90%EC%A0%81-%EA%B8%B0%EA%B3%84%EC%99%80-%EC%8A%A4%ED%82%A4%EB%A7%88%ED%83%80)
* [7장 생각의 버그](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#7%EC%9E%A5-%EC%83%9D%EA%B0%81%EC%9D%98-%EB%B2%84%EA%B7%B8)
  * [왜 두 번째 프로그래밍 언어가 첫 번째보다 쉬울까?](https://github.com/HoyiTT/TIL/blob/master/%EB%8F%84%EC%84%9C/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98_%EB%87%8C.md#%EC%99%9C-%EB%91%90-%EB%B2%88%EC%A7%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4%EA%B0%80-%EC%B2%AB-%EB%B2%88%EC%A8%B0%EB%B3%B4%EB%8B%A4-%EC%89%AC%EC%9A%B8%EA%B9%8C)
# 1장 코딩 중 겪는 혼란에 대한 이해
## 코드가 초래하는 세 가지 종류의 혼란
첫째. 프로그래밍 언어나 알고리즘 혹은 업무 영역에 대한 지식이 없는 경우 혼란이 생길 수 있다.

둘쨰. 코드를 이해하기 위해 필요한 정보를 충분히 가지고 있지 못하는 경우에도 그렇다

셋째. 코드가 너무 복잡해서 혼란이 생기는 경우인데, 이는 두뇌의 처리 용량이 부족하기 떄문이다.



## 코딩에 영향을 주는 인지 과정
지식이 없다는 것은 두뇌에 장기 기억 공간(LTM)에 해당 내용이 없다는 것을 말한다.

지식이 아닌 어떤 정보가 부족할 때에는 단기 기억 공간(STM)에 해당 내용이 없기 때문이다.

많은 정보를 처리할 떄는 작업 기억 공간에 영향을 미치는데 우리는 사고할 때 이 영역을 사용한다.


LTM : 오랜 시간에 걸쳐 얻은 정보를 저장

STM : 방금 전에 읽거나 들은 정보를 일시적으로 저장하는 장소

## 인지 과정들의 상호 작용
우리가 사고할 때는 이 세가지 인지과정들이 상호작용하며 사고하게 된다.

# 2장 신속한 코드 분석

연구에 의하면 프로그래머의 시간 중 거의 60%를 코드를 '작성'하는게 아니라 '이해'하는 데 사용한다고 한다.

## 코드를 신속하게 읽기
삽입 정렬과 같은 알고 있는 내용(LTM)에 연관되어 작성하는 코드는 짧은 시간내에 읽고 쓰기가 가능하지만 생소한 코드(어떤 작업을 하는 지 파악하기 어려운 코드)는 짧은 시간 내에 읽고 쓰기가 어렵다. 바로 STM의 용량에 제한이 있기 때문이다.  두뇌에서 STM의 용량은 불과 몇 개 밖에 되지 않는다. 이 작은 용량을 극복하기 위해 STM은 LTM과 협업하여, 읽거나 기억한 정보를 이해한다.

## 기억의 크기 제한을 극복하기
특정한 주제에 대해 두뇌가 더 많은 정보를 저장하고 있다면 입력된 정보들을 효율적으로 청크로 묶는 것이 수월해진다. LTM에 지식이 많으면 기억을 쉽게 한다는 사실은 프로그래밍에도 해당한다.

## 읽는 것보다 보는 것이 더 많다

# 3장 프로그래밍 문법 빠르게 배우기
 프로그래밍의 언어와 문법, 개념과 자료구조를 외우면 코드를 더 빨리 파악하는데 도움이 된다.
## 문법을 기억하기 위한 팁
잘 모르거나 기억이 나지 않는 문법에 대해 항상 검색하는 방식은 좋은 해결책이 아니다.

관련 내용을 미리 알고 있는 것이 코드를 효율적으로 읽고 이해하는데 상당한 영향을 끼친다.

또한 두뇌가 작업을 하다 업무 중단을 받게 되면, 우리가 생각한 것보다 훨씬 악영향을 끼친다.

## 플래시카드 사용해 문법 배우기
앞면에 개념을 적어놓고 뒷면에 해당하는 코드를 적는다.

새로운 프로그래밍 언어나 프레임워크 혹은 라이브러리를 배울 때 사용하면 좋다.

## 어떻게 하면 잊어버리지 않을 수 있을까?
LTM은 정보가 상대적으로 안전하고 오랫동안 저장되는 컴퓨터 하드드라이브와는 많은 차이가 있다.

한 시간 이내에 우리가 알고 있는 것의 반 정도를 잊어비리고, 이틀 후에는 배운 것의 25%만 남는다.


오랜 기간 동안 학습한 경우가 짧은 기간 많은 양을 학습 할 떄에 비해 더 오래 기억한다.

플래시카드를 한 달에 한 번 다시 학습하면 충분하다.

이것은 정규교육기관에서 한 학기 동안 혹은 부트캠프에서 3달 동안 배운 모든 지식을 머릿속에 집어넣어야 하는 경우에 극명히 대비된다.

## 문법을 더 오랫동안 기억하기
인출 : 학습을 추가로 하지 않고 정보를 기억하려고 능동적으로 노력하는 것만으로도 배운 것을 더 많이 기억할 수 있다.
기억이 나지 않는 문법에 대하여 검색 이전에 그것을 능동적이고 의도적으로 기억하려고 시도해보자.

정교화 : 머리속에 집어 넣고자 하는 내용을 가존 기억과 연관 지으면서 생각하면  조금 더 잘 기억할 수 있다. 새로운 정보를 더 잘 기억하고 싶다면 그 정보를 정교화 하는 것이 좋다.


# 4장 복잡한 코드 읽는 방법
## 복잡한 코드를 이해하는 것이 왜 어려울까?
STM과 작업 기억 공간은 동의어가 아니다. 예를 들자면 수식을 기억하는 일은 STM을 사용하고 수식을 계산하는 것은 작업 기억 공간에서 이루어진다.
STM과 같이 작업 기억 공간도 한 번에 2개에서 6개까지만 기억할 수 있다. 작업 기억 공간의 맥락에서 이 용량을 인지부하라 부른다.

직각삼각형의 빗변의 길이를 알기 위해서는 피타고라스의 정리를 알아야만 빗변의 길이를 구할 수 있다. 다른 방법이 존재하지도 않으며 이 문제의 부하는 문제에 내재해있다. 이러한 경우를 프로그래밍에서는 "내재적 복잡성"이라고 하며 "내재적 인지 부하"라 부른다.
이제 빗변의 길이를 구하기 위해 나머지 두 변의 길이를 식에 대입하려고 할 때 a^2 + b^2 = c^2 식에 a와 b에 직접 a = 7, b = 8 과 같은 값을 대입하려고 할 때 이러한 추가적인 작업 떄문에 더 큰 "외재적 인지 부하"가 발생한다고 한다.

## 인지 부하를 줄이기 위한 기법
1. 리팩터링 : 코드가 외부적으로 제공하는 기능은 유지 한 채 코드의 내부 구조를 개선하는 것을 의미힌다.

2. 생소한 언어 구성 요소를 다른 것으로 대치하기 

## 작업 기억 공간에 부하가 오면 쓸 수 있는 기억 보조 수단
1. 의존 그래프 생성 : 코드를 pdf로 출력하거나 태블릿으로 열어서 디지털 주석을 달면 좋다
    ```
    1. 모든 변수를 원으로 표시한다.
    2. 비슷한 변수를 연결한다.
    3. 모든 메서드나 함수 로출을 원으로 표시한다.
    4. 메서드나 함수 호출을 정의와 연결한다.
    5. 클래스의 모든 인스턴스를 원으로 표시한다.
    6. 클래스와 그 클래스의 인스턴스를 연결한다.
    ```

2. 상태표 사용 : 코드에서 사용되는 계산 로직떄문에 어려울 수 있다. 각 변수를 순서대로 적는 상태표를 만들면 도움이 된다.

# 5장 코드를 더 깊이 있게 이해하기
## '변수 역할' 프레임 워크
코드에 대해 추론할 때는 변수가 중심적인 역할을 한다. 어떤 변수가 나타내고자 하는 것을 이해하지 못하면 코드에 대해 생각하는 것이 매우 어려워진다.

사야니에미는 다음과 같은 11개의 역할로 대부분의 변수를 설명할 수 있다고 주장한다.
이를'변수 역할'이라는 프레임 워크라 부른다.

고정값,스테퍼,플래그,워커,최근값 보유자,목적값 보유자,모집자,컨테이너,추적자,조직자,임시

## 역할과 패러다임
이 프레임워크는 새로운 개념이라기보다는 변수에 대해 논의할 때 사용할 수 있는 새로운 용어를 제공해주는 정도로 생각하면 된다. 이 프레임워크를 같은 팀원끼리 공유하면 코드를 이해하고 의사소통하는데 큰 도움을 줄 것이다. 코드를 종이에 프린트해서 노트에 적는 연습은 매우 유용하다. 규모가 큰 프로젝트라면 모든 소스를 인쇄하는 것은 불가능하겠지만 하나의 클래스 혹은 프로그램의 부분에서 시작할 수 있다.

헝가리안 표기법 : 변수의 타입을 변수명에 나타내는 방식

ex) strName => 이름을 나타내는 문자타입의 변수, lDistance => 거리를 나타내는 롱 타입의 변수

오늘날에는 대부분의 에디터에서 변수의 타입을 쉽게 확인할 수 있고 변수명이 길어지는 단점이 있기에 보통은 권장되지 않는다.

## 프로그램에 대해 깊이 있는 지식을 얻으려면
콜로라대 교수 낸시 페닝턴은 프로그래머가 소스 코드를 이해하는 두 개의 서로다른 층위에 대한 모델을 제시했다. 두 층위는 "텍스트 구조 지식"과 "계획 지식"이다.

텍스트 구조 지식 : 키워드가 하는 일이나 변수의 역할 같은 프로그램의 표면적인 이해와 관련되어 있다. 

계획 지식 : 프로그래머가 프로그램을 작성할 때 계획한 것이 무엇인지 혹은 무엇을 달성하려고 했는지를 나타낸다.

브리검영대 교수 조너선 실리토는 코드를 이해하는 4가지 단계에 대해서 정의했다.

1. 초점을 찾는다.(main() 메서드나 onLoad() 메서드)

2. 초점으로부터 지식을 확장한다.

3. 관련된 개체로부터 개념을 이해한다.

4. 여러 개체에 걸쳐 있는 개념을 이해한다.

코드를 읽을 때 초점은 중요한 개념이다.

위의 방법을 4장에서 설명했던 의존그래프와 연관지어 적용하면 코드를 더욱 더 깊게 이해하는데 큰 도움이 된다.

## 텍스트를 읽는 것과 코드를 읽는 것은 유사하다
프로그래머는 평균적으로 자신의 업무 시간의 60%를 코드 작성이 아닌 읽는 데 사용한다.하지만 연습의 부족, 좋은 전략과 휼륭한 스키마의 부족으로 코드를 한 줄 한 줄 읽거나 라인 단위로 실행시키곤 하는데 이러한 방법은 시간을 많이 소비하게 된다.결국 코드를 파악해서 재사용하거나 수정하기 보다는 자신이 코드를 처음부터 다시 작성하는 것을 선호하게 된다. 인간의 언어로 된 글을 읽듯이 코드를 읽는 것이 쉽다면 어떨까?

연구자들은 개발자가 오랜 시간 프로그래밍 작업을 할 때 두뇌에서 어떤 일이 일어나는지 이해하려고 노력해왔다.브로드만 영역과 연관된 실험에 의해 프로그래밍을 할때 인간의 뇌는 인간 언어를 이해하는 활동과 비슷한 활성도를 나타냄을 밝혀냈다.
위싱턴 대학교의 샨텔 프랫교수의 실험에 따르면 수학적인 능력도 중요하지만 언어 능력도 상당히 중요하다는 점을 알아냈다. 즉, 코드 아카데미의 수업을 얼마나 빨리 마쳤는지에 대한 측도는 언어 능력이 가장 큰 요인이였다. 

텍스트와 맥락을 잘 이해하기 위해, 의도적으로 텍스트를 다라 실린 그림만 볼 수도 있고, 혹은 읽고 있는 것을 요약하거나 가장 중요한 부분을 하이라이트하든지 할 수 있다.
텍스트를 훍는 동시에 함께 실린 그림을 보는 것은 '텍스트 이해 전략'이다.
우와노 히데타케교수의 실험에 따르면 프로그래머들은 코드를 전체적으로 파악하기 위해 처음 30%시간 동안 코드의 70%를 훑어본다는 점을 알아냈다. 이런 유형의 스캔은 자연어로된 텍스트의 구조를 파악하는 방식과 유사하다.

## 코드 읽기에 적용해볼 수 있는 텍스트 이해 전략
앞 섹션에서 살펴봤듯 코드를 읽을 때 사용하는 인지적 능혁은 자연어를 읽을 때와 유사하다. 

효과적인 읽기 전략과 그 학습법에 대한 연구가 지금까지 많이 이루어졌다. 텍스트 이해에 대한 전략은 다음과 같은 7개의 범주로 나뉜다.
### 1. 기존 지식의 "활성화"

    처음 보는 코드를 볼 때 먼저 스캔을 하게된다. 
    
    그 이유는 바로 코드 내에 존재하는 개념과 문법적 요소들에 대한 일차적인 이해가 가능해지기 때문이다. 
    
    코드에 대해 스캔하며 관련 지식 및 기억을 LTM으로 부터 검색하게 된다는 것을 이전 장에서 살펴봤다.

    코드의 구성요소에 대해 생각하면 LTM으로 부터 유용한 정보를 찾는데 큰 도움이 된다.

### 2. "모니터링"

    코드를 읽을 때 현재 무엇을 읽고 있는지, 이해는 하고 있는지를 계속 추적하는 것이 중요하다.
  
   이해되는 것 뿐만 아니라 이해되지 않는 것도 머리속에서 기억해야 한다.이해되지 않는 라인과 이해되는 라인을 표시하는 것도 좋다.

### 3. 코드에서 중요한 라인을 결정하기("중요도 결정")

    코드에서 어떤 라인이 중요한지 파악하는 것이 유용할 때가 있다. 얼마나 많은 라인을 설정하는지는 즁요하지 않다(대략 10~25라인정도) 

### 4. 변수명의 의미를 "추론"하기

    변수 이름은 중요한 표식이다. 즉 코드가 하는 일에 대한 힌트를 제공하는 기능을 한다. 따라서 코드를 읽을 때 의식적으로 변수에 주목하면 좋다.

### 5. "시각화"

    코드를 좀 더 깊이 이해하기 위해 상태표를 작성하거나 하는 시각화 방법은 이전 장에서 살펴봤었다. 이러한 방법은 여러가지가 더 있다.

    <연산 테이블> 
    익숙하지 않은 코드에 대해 변수에 값이 어떻게 변하는지 예측하기 어려울 때가 있다.코드가 너무 어려워 이해되지 않을 때에는 연산 테이블을 만들면 도움이 된다.


    익숙하지 않는 코드에서 일부분을 선정하고 모든 변수, 함수, 클래스의 이름을 적는다. 각 식별자와 관련되는 모든 연산을 나열해보는 것이다

    테이블을 만들고 나면 코드를 다시 읽어보자.

### 6. "질문하기"

    코드를 읽을 때 스스로에게 질문하는 것이 코드에 목적과 기능에 대해 이해하는 데 도움이된다.

    다음은 그 예이다.
    
    코드에서 다섯가지의 중심 개념은 무엇인가? 이 중심 개념이 식별자, 테마, 클래스, 혹은 주석문내의 정보로 나타나는가?

    중심 개념을 찾기 위해 어떤 전략을 사용했는가? 예를 들어 메서드 이름, 문서 혹은 변수명을 살펴봤다거나 아니면 시스템에 대해 이미 가지고 있는 지식을 활용했는가?

    등등등

### 7. 코드 "요약"

    코드 이해를 위해 적용할 수 있는 텍스트 읽기 전략 가운데 마지막으로, 
    
    방금 전에 읽은 코드를 요약하는 것이 있다. 
    
    코드를 우리가 사용하는 언어로 요약하는 것은 코드가 하는 일을 깊이 이해하는 데 도움이 된다.




# 6장 코딩 문제 해결을 더 잘하려면
이 장에서는 문제를 어떻게 해결하는지에 대해 살펴보려고 한다. 문제에 대한 다양한 해결책이 있을 때 무엇을 고를지는 굉장히 어렵다. 예를 들어 사용의 용이함과 성능 중에서 어떤 것을 더 높은 우선순위로 둘 것인가 등등 여러가지 고려해야할 요인이 많다.

이 잘에서는 여러가지 소프트웨어 설계에 관한 결정을 할 때 통창력을 얻는 데 도움이 될만한 두가지 프레임워크에 대해 배운다.

## 모델을 사용해서 코드에 대해 생각해보기
사람들은 문제를 해결할 때 대부분 모델을 만든다. 모델은 실재를 간단하게 표현한 것으로 문제에 대해 생각하고 해결하는 데 도움을 주기 위한 것이다(ex 이면지에 대충 계산한 모습, 개체 관계도 등등)

이전 장에서 살펴보았던 의존 그래프도 이러한 모델 중에 하나이다.모델을 사용하는 것은 두가지의 장점이 있다.

첫째. 모델은 프로그램에 대한 정보를 다른 사람과 공유할 때 유용하다.

각 단계의 변수의 값을 통해 코드가 어떻게 작동하는지 이해하는 데 큰 도움을 줄 수 있다. 이것은 특히 대규모 시스템에서 유용하다.

둘째. 문제를 풀 때 도움이 된다.

두뇌에서 한 번에 처리할 수 없는 한계에 도달했을 때 큰 도움을 받을 수 있다.

하지만 각각의 문제에 대해 사용하는 모델이 다 동일할 수는 없다.
## 정신 모델
문제에 대해 생각할 때 두뇌의 외부에서 만들어지지 않은 모델을 사용할 수도 있다. 이러한 모델을 __정신모델__ 이라고한다.

정신 모델은 문제를 해결하는 데 도움이 된다. 하지만 정신 모델은 실제로 존재하지 않는다. 그저 두뇌의 외부에서 만들어진 것일 뿐이다.

코드를 위해 사용할 정신 모델의 예는 트리 순회에 대해 생각해보는 것이다.

트리는 실제로는 존재하지 않는다. 그저 메모리 내에 값이 있을 뿐이다.

우리는 컴퓨터와 상호작용할 때 많은 종류의 정신 모델을 만든다. 컴퓨터 파일 구조를 생각할 때 실제 폴더 안에 종이처럼 파일이 들어있는 모습을 생각하지만 실제로는 0과 1일 뿐이다.

정신 모델이 정확하고 구체적이면 복잡한 시스템에 대해 생각할 때 도움이 된다.코드가 단순하면 많은 노력 없이 정신 모델을 만들 수 있지만 코드가 복잡하거나 코드베이스나 도메인에 대한 지식이 부족한 경우 정확한 정신 모델을 만드는 데 더 많은 노력이 필요하다.

복잡한 코드의 정신 모델을 만드는 데 도움이 되는 순서

1. 국지적 모델을 만든다
2. 코드에서 관련된 모든 객체와 객체 간의 관계를 나열한다.
3. 시스템에 대한 질문을 만들고 이 질문의 답을 사용해서 모델을 개선한다.

## 개념적 기계
개념적 기계는 컴퓨터가 코드를 실행하는 방법에 대해 추론할 때 사용하는 모델이다. 전기를 사용하여 비트를 저장하는 방식 같은 세부사항이 아닌 두 개의 값을 교환하거나 목록에서 가장 큰값을 찾는 등 프로그래밍언어를 통해 더 높은 개념적 수준에서 수행하는 작업의 차이를 나타내기 위해 __개념적 기계__ 라는 용어를 사용한다.

개념적 기꼐는 컴퓨터가 작동하는 방식을 설명하는 것이라는 점이 정신모델과의 차이점이다.

## 개념적 기계와 언어
프로그래밍에 관해 말할 때는 암시적으로 개념적 기계가 그 바탕에 깔려 있고 특정 정신 모델로 이어지는 경우가 많다. 예를들어 우리는 파일이 '열림'또는 '닫힘' 이라고 말한다. 

일반적으로 사물의 작동 방식을 설명하는 데 사용되는 개념적 기계는 우리가 코드에 대해 이야기할 때 사용하는 언러, 심지어는 프로그래밍 언어에서도 발견된다.

개념적 기계 라는 용어를 사용할 때 어떤 한 시점에는 오직 하나의 개념적 기계만 있는 것은 아니다.서로 겹치는 여러 갸의 개념적 기계들이 있다. 

하지만 여러 개념적 기계는 서로 충돌하는 정신 모델을 만들 수 있다.
이 책에서는 한 실험을 예시로 들었다. 스크래치를 통해 코딩을 처음 접하는 학생들을 대상으로 한 집단은 변수라는 개념을 '라벌'로 인식하도록 수업하고 다른 한 집단은 '상자'로 인식하도록 수업을 진행하였다. 이 실험은 변수에 대한 두 가지 서로 다른 은유가 각각 장단점이 있다는 것을 명확히 보여주었다. 

한번 값을 할당하는 간단한 질문 -> 상자 그룹이 더 잘함

변수가 두가지 값을 가질 수 있다고 오해하는 사람의 비ㄹ율 -> 상자 그룹이 더 높음


## 개념적 기계와 스키마타
스키마타는 LTM이 정보를 저장하는 방식이다.예들 들어 상자에 대해 사람들이 가지고 있는 생각은 강한 연관성을 갖는 개념일 가능성이 매우 높다. "변수는 외발자전거와 같다"라는 표현은 별로 도움이 안 될 것이다.



# 7장 생각의 버그
## 왜 두 번째 프로그래밍 언어가 첫 번쨰보다 쉬울까?
LTM에 저장된 키워드 및 정신 모델이 코드를 이해하는 데 도움이 된다느 것은 앞에서 학습했다. 때때로 무언가를 배울 때, 이미 배운 지식은 다른 영역에서도 유용하다. 이것을 __전이__ 라고 한다.

체커를 이미 할 줄 아는 사람은 체스를 더 쉽게 배우고, 자바를 이미 할 줄 아는 사람은 파이썬을 더 쉽게 배운다.

LTM에 저장된 프로그래밍 지식은 새로운 프로그래밍 개념을 배우는 데 두 가지 방식으로 도움이 된다.

첫째, 프로그래밍에 대해 이미 많이 알고 있다면 그것에 대해 더 많이 학습하는 것이 쉬워진다. LTM에 저장된 정보를 사용해서 새로운 내용을 쉽게 배우는 이 과정을 __학습 도중 전이__ 라고 부른다.

둘째, 완전히 낯선 상황에 이미 알고 있는 내용을 적용하면 그것을 이해하는 데 도움이 된다. 이 과정을 __학습 전이__ 라고 부른다.

### 기존 프로그래밍 지식을 활용할 가능성을 높이는 방법
어떤 라이브러리의 특정 기능이 어떻게 작동하는지 이해가 되지 않았지만 나중에 알고보니 잘 알고 있던 라이브러리 였던 경험이 있었을 것 이다. 안타깝지만 유용한 모든 지식이 자동으로 새로운 상황으로 전이되지는 않는다.

이러한 전이는 많은 요인의 영향을 받는다.

숙달 , 유사성, 배경, 중요 특성, 연관, 감정 등의 영향을 받는다.

프로그래머들은 떄댸로 프로그래밍 언어 간의 문법의 차이는 사소하다고 생각한다. 한 어를 알면 두 번째 언어는 쉽고, 세 번째 언어는 더 쉬울거라고 생각한다. 물론 한 언어를 배우면 새로운 언어를 쉽게 배우는 것은 사실이지만, 항상 도움만 되는 것은 아니다. 다른 형태의 전이를 이해하면 새로운 언어나 프레임워크를 더 효과적으로 배울 수 있다.

저도 전이 : 자동화된 기슬을 이전하는 행위 (EX : 복사 , 붙여넣기)

고도 전이 : 이에 반해 복잡한 작업이 전이되는 것 (EX : 변수를 선언해야 사용할 수 있다고 이미 학습된 경우 새로운 언어를 배울때에도 선언 후 사용해야 한다고 가정하게 됨)

근거리 전이 : 가까운 영역 사이에서 지식이 전이되는 것 (EX : 미적분학과 대수학, 자바와 C#)

원거리 전이 : 서로 먼 영역 간에 일어나는 전이 (EX : 자바와 프롤로그)

유사성은 전이에 영향을 미침 -> 원거리 전이가 근거리 전이보다 일어날 가능성은 적다.

긍정적 전이 : 무언가를 알고 있어 새로운 것을 배우거나 새로운 작업을 할 때 도움이 되는 전이

부정적 전이 : 기존 지식이 새로운 것을 배우는데 방해가 되는 전이

지식의 전이는 부정적이면서 동시에 긍정적이고, 긍정적이기만 한 전이가 보장되지는 않는다.

하나의 프로그래밍 언어를 숙달했다는 사실이 새로운 언어를 배우는 데 항상 도움이 되는 것은 아니라는 것이다.

## 오개념 : 생각의 버그
코드가 작동한다고 확인함에도 불구하고 여전히 오류가 발생한다면 코드에 대한 __오개념__ 이 문제일 가능성이 있다.

오개념의 형식적인 정의
* 사실과 다르다
* 서로 다른 상황에서 일관되게 유지된다.
* 확신에 사로 잡혀있다.

오개념의 예시
1. 사실과 다르다
2. 만약 사람들이 한 종류의 고추의 씨앗이 맵다고 믿는다면, 그들은 모든 종류의 고추의 씨앗이 맵다고 믿을 것이다.
3. 그들은 그것이 사실이라고 굳게 믿고 , 가령 고추의 씨를 제거하고 요리한다.

계란(단백질)의 겉면이 단단해지는 것을 보며 고기 겉면을 바삭하게 해야 육즙이 가둬지는 것처럼 생각하는 것이 바로 오개념이다.

이미 알고 있는 프로그래밍 언어 때문에 생긴 오개념을 현재 학습 중인 새로운 언어에 맞는 정신 모델로 대체하는 과정을 __개념 변화__ 라고 한다.

이미 학습한 지식을 LTM에서 변경해야 하기 떄문에 개념 변화 학습은 일반적인 학습보다 어렵다.

### 프로그래밍 언어에 대한 오개념
핀란드 알토 대학교의 수석 강사인 유하 소르바는 2012년 논문에서 초보 프로그래머가 가질 수 있는 162가지의 오개념을 나열했다.

그 중 흥미로운  오개념 몇 가지를 소개한다.
* 오개념 15 : 원시 데이터 타입 변수에 대한 할당은 수식 또는 아직 연산 실행이 되지 않은 표현식을 저장한다.
* 오개념 33 : 조건이 거짓으로 변경되는 즉시 while루프가 종료된다.
* 오개념 46 : 매개변수 전달에는호출과 정의에 서로 다른 변수 이름이 필요하다.


### 새로운 프로그래밍 언어를 배울 때 오개념을 방지하기
1. 자신이 옳다고 확신하더라도 여전히 틀릴 수 있다는 것을 인지한다.
2. 흔하게 발생하는 오개념에 대해 의도적으로 연구해봄으로써 그런 오개념에 빠지는 것을 방지한다.
3. 같은 프로그래밍 언어를 같은 순서로 학습한 다른 프로그래머들에게 조언을 구한다.


# 8장 명명을 잘하는 방법

## 이름이 중요한 이유
넷스케이프의 프로그래머 필칼튼은 컵퓨터 과학에는 난제가 딱 두 가지 있는데 , 바로 캐시 무효화와 아룸 짓기라는 유명한 말을 했다.

식별자 이름이 중요한 이유는 크게 네 가지다.
1. 이름은 코드베이스의 상당 부분을 차지한다.
2. 코드 리뷰 시 이름의 역할이 크다.
3. 이름은 문서화의 가장 쉬운 형태이다.
4. 이름이 표식 역할을 할 수 있다.

### 명명에 대한 다양한 관점
영국 오픈 대학교의 강사 사이먼 버틀러는 변수 이름과 관련된 이슈 목록을 만들었다.

버틀러의 리스트는 여러 종류의 규칙을 포함하지만, 대부분은 문법과 관계가 있다.

## 명명의 인지적 측면

이름을 짓는다는 것은 변수 이름에 대한 올바른 단어를 선택하는 것 그 이상의 일이다. 우리가 선택하는 단어들은 특히 인지적인 관점에서 중요하다.

식별자 이름에 세가지 유혀의 지식을 표현할 수 있으며 이를 통해 익숙하지 않은 이름을 빠르게 이해하는 데 도움을 얻을 수 있다.

1.코드의 도메인에 대해 생각할 때 이름이 도움이 된다.

2.프로그래밍에 대해 생각할 떄도 이름이 도움이 된다.

3.경우에 따라 변수에 이미 LTM이 이미 알고 있는 규약에 대한 정보가 포함될 수도 있다.

코드 리뷰 시 명명 규약에 주의를 특별히 환기하기 위해 이 리스트를 사용할 수 있다.

* 코드에 대해 아무것도 모르는 상태에서, 이름이 무엇을 의미하는지 명확한가? 예를 들어 이름이 구성하는 단어의 의미를 알겠는가?
* 이름이 모호하거나 불명확한가?
* 혼란을 줄 수 있는 약어를 사용하는가?
* 어떤 이름들이 서로 비슷한가? 이 이름들은 서로 비슷한것들을 가리키는가?

