# DFS

``` python
def dfs(c):
    ansDfs.append(c)
    v[c] = 1
    for n in g[c]:
        if not v[n]:
            dfs(n)
```

# BFS

``` python
def bfs(s):
    q = deque()
    q.append(s)
    ansBfs.append(s)
    v[s] = 1
    
    while q:
        c = q.popleft()
        for n in g[c]:
            if not v[n]:
                q.append(n)
                ansBfs.append(n)
                v[n] = 1
    
```

# 방문 체크가 필요한 경우와 필요하지 않은 경우 구분하기

방문 체크가 필요한 경우와 그렇지 않은 경우를 이해하려면, **탐색 문제의 특성과 상태의 중복 여부**를 잘 이해하는 것이 중요하다. 

## 1. 상태 중복 여부 확인

- **방문 체크가 필요한 경우**: 문제를 해결하는 과정에서 **동일한 상태를 여러 번 방문할 수 있는 경우** 방문 체크가 필요하다.
  - 예) 그래프 탐색 문제에서 같은 노드를 다시 방문하면 **무한 루프**에 빠지거나 불필요한 중복 계산이 발생할 수 있다.
  - 예) **최단 경로 문제**에서는 한 번 방문한 노드에 다시 방문할 필요가 없으므로 방문 체크로 효율을 높인다.

- **방문 체크가 필요하지 않은 경우**: 모든 조합이나 경로가 **고유한 경우** 방문 체크가 필요하지 않다.
  - 예) `햄버거 다이어트 문제`는 각 재료에 대해 "선택" 또는 "미선택"을 결정하는 모든 경우의 수를 완전 탐색하므로 중복 상태가 발생하지 않는다.

## 2. 탐색 방식에 따른 차이 (DFS/백트래킹 vs BFS)

- **DFS/백트래킹으로 조합을 완전 탐색하는 경우**:
  - 선택 과정에서 한 번 선택된 경로는 다시 돌아오지 않으므로, 재귀적으로 완전 탐색할 때 방문 체크가 필요하지 않다.
  - 예) `햄버거 다이어트 문제`, `부분 집합 문제` 등 조합이나 부분 집합을 찾는 문제는 특정 요소의 선택 유무를 기준으로 모든 가능한 조합을 탐색하기 때문에 방문 체크가 필요하지 않다.

- **BFS 탐색이나 경로 추적이 필요한 경우**:
  - BFS나 DFS로 그래프의 모든 경로를 탐색하는 문제에서는 **중복된 상태를 방문할 가능성**이 있다. 이 경우 방문 체크를 생략하면 무한 루프에 빠지거나 불필요한 연산이 발생할 수 있다.
  - 예) 최단 거리 문제, 미로 문제 등은 이미 방문한 노드를 다시 방문할 필요가 없으므로 방문 체크로 불필요한 탐색을 줄인다.

## 3. 최적화 목적에 따른 차이

- **방문 체크로 최적화를 하는 경우**:
  - 경우의 수가 많고, 동일한 상태를 여러 번 계산하는 것이 비효율적일 때 방문 체크로 중복 계산을 줄인다.
  - 예) 동적 계획법(DP) 문제에서는 같은 상태를 여러 번 계산하는 것이 비효율적이므로, 이미 계산된 값을 저장해 중복 계산을 피한다.
  - 예) 피보나치 수열 문제, 특정 점수에 도달할 수 있는 모든 방법 찾기, 메모이제이션이 필요한 경우.

- **최적화가 필요 없는 경우**:
  - 문제에서 요구하는 모든 경우의 수를 탐색해도 성능상 문제가 없거나, 특정 조건이 없는 경우 방문 체크 없이 완전 탐색을 진행해도 괜찮다.

## 4. 문제 유형에 따른 차이점

- **경로 또는 그래프 문제**: 대부분의 경로 탐색 문제는 동일한 위치를 반복 방문할 수 있기 때문에 방문 체크가 필요하다.
- **조합과 부분집합 문제**: 모든 조합을 찾거나, 모든 부분 집합을 찾는 문제는 선택과 미선택이 명확하므로 방문 체크가 필요하지 않다.

## 예시로 이해하기

1. **방문 체크가 필요한 예시**: **미로 탐색 문제**
   - 시작점에서 끝점까지 최단 거리를 찾아야 하는 문제에서, 같은 노드를 다시 방문할 경우 되돌아갈 가능성이 생긴다. 이럴 경우 방문 체크가 없으면 무한 루프에 빠지거나 불필요한 중복 탐색이 발생할 수 있다.

2. **방문 체크가 필요 없는 예시**: **햄버거 다이어트 문제**
   - 각 재료에 대해 "포함" 또는 "미포함"을 결정하는 경우의 수를 모두 탐색한다. 각 재료 선택이 독립적이고 조합을 모두 탐색하므로, 중복된 조합을 다시 탐색할 가능성이 없기 때문에 방문 체크가 필요하지 않다.

---

## 결론: 방문 체크 필요 여부 판단 방법

- **그래프 탐색 문제**에서 특정 노드를 반복 방문할 가능성이 있다면 방문 체크가 필요하다.
- **모든 조합을 찾는 문제**에서는 방문 체크가 필요하지 않다.


# 리스트로 방문 처리를 할 수 없는 이유

    리스트는 방문 처리를 할 때 시간복잡도가 O(N)이기 때문에 비효율적이기도 하지만,
    근본적으로 파이썬에서 리스트는 주소값을 참조하는 방식이기 때문에 방문 처리를 할 수 없다.
    동일한 요소를 가지더라도 주소값이 다르기 때문이다.

# Queue

``` python
from collections import deque

q = deque()

q.append(1)
q.popleft()
```

# set을 이용한 연산

sorted를 활용해 set에서 - 연산을 할 수 있다.

``` python
ori = set(i for i in range(1, 10001))

data = set()

for i in range(1, 10001):
    tmp = i
    i = str(i)
    for s in range(len(i)):
        tmp += int(i[s])
    data.add(tmp)

ans = sorted(ori - data)
```

# combinations 활용

``` python
from itertools import combinations
chickens = [(0,1), (0,2),(0,3)]
M = 2
for chicken_comb in combinations(chickens, M):
    print(chicken_comb)
```
실행 시

```
((0, 1), (0, 2))
((0, 1), (0, 3))
((0, 2), (0, 3))
```

와 같이 조합을 구할 수 있다.

# 리스트 컴프리헨션 (List Comprehension)

리스트 컴프리헨션을 사용하면 반복문과 조건문을 간단하게 작성하여 리스트를 생성할 수 있습니다. 기본 구문은 다음과 같습니다:

```python
[표현식 for 변수 in iterable if 조건문]

even_numbers = [x for x in range(1, 11) if x % 2 == 0]
print(even_numbers)  # 출력: [2, 4, 6, 8, 10]
```


