# QuickSort  

## 퀵정렬이란?

퀵 정렬은 분할 정복 알고리즘의 하나로, 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬방법

퀵 정렬은 n개의 데이터를 정렬할 때, 최악의 경우에는 O(n^2)번의 비교를 수행하고, 평균적으로 O(n log n)번의 비교를 수행

퀵 정렬의 내부 루프는 대부분의 컴퓨터 아키텍처에서 효율적으로 작동하도록 설계되어 있음(메모리 참조가 지역화되어 있기 떄문에 CPU캐시 히트율이 높아짐)

대부분의 실질적인 데이터를 정렬할 때 제곱 식산이 걸릴 확률이 거의 없도록 알고리즘 설계하는 것이 가능하다.



## 퀵 정렬 알고리즘 구체적인 개념

하나의 리스트를 피벗을 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.

퀵 정렬은 3단계로 이루어져있다.

* 1단계. 분할(Divide) : 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽 = 피벗보다 작은 요소들, 오른쪽 = 피벗보다 큰 요소들)로 분할한다.

* 2단계. 정복(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용한다.

* 3단계. 결합(Combine) : 정렬된 부분 배열들을 하나의 배열에 합병한다.

순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다. 

## 동작원리

1. 리스트 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗(pivot - 기준점을 의미하기 떄문에 다르게 불러도 된다. 다만 피벗이라 많이 칭함)이라고 한다.

2. 피벗 앞에는 피봇보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로 나눈다. 이렇게 리스트를 둘로 나누는 것을 분할이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.

3. 분할된 두 개의 작은 리스트에 대해 재귀적으로 이 과정을 반복한다. 재귀는 리스트의 크기가 0이나 1이 될 때까지 반복된다.

## 동작절차

1) 배열의 값 중 하나를를 피벗(pivot)으로 설정한다. 

2) low 는 left + 1 자리부터 피벗과 비교하면서 한칸씩 증가한다.

3) high 는 right 자리에서부터 피벗과 비교하면서 한칸씩 감소한다.

4) 위의 절차를 반복한다. low와 high가 엇갈리면 정지한다.

5) 피벗값과 high 값을 SWAP한다.

6) 피벗을 기준으로 왼쪽, 오른쪽 두개의 배열을 반복한다.

7) 더 이상 나눠질 수 없을 때까지 재귀적으로 반복한다.

8) 정렬이 완료된다.

## 장단점

### 장점
평균적으로 빠르고 효율적이다.
추가적인 메모리 사용이 적다(인플레이스 방식으로 구현 시).
### 단점
최악의 경우 성능이 급격히 떨어진다.
재귀 호출 스택이 깊어질 수 있어 스택 오버플로우 위험이 있다.


## 파이썬 코드

```python
def quick_sort(arr):
    if len(arr) <= 1:  # 리스트의 길이가 1 이하일 경우, 정렬 완료
        return arr
    
    pivot = arr[len(arr) // 2]  # 중간값을 피벗으로 선택
    left = [x for x in arr if x < pivot]  # 피벗보다 작은 값
    middle = [x for x in arr if x == pivot]  # 피벗과 같은 값
    right = [x for x in arr if x > pivot]  # 피벗보다 큰 값
    
    return quick_sort(left) + middle + quick_sort(right)  # 재귀 호출로 정렬

# 예제 실행
arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))  # [1, 1, 2, 3, 6, 8, 10]
```



# 퀵 정렬 실행 예제

입력 배열: `arr = [3, 6, 8, 10, 1, 2, 1]`

---

## 1단계: 첫 호출
입력 배열: `[3, 6, 8, 10, 1, 2, 1]`

- **피벗**: `3` (첫 번째 요소)
- **분할**:
  - `left = [1, 2, 1]` (피벗 `3`보다 작거나 같은 값들)
  - `right = [6, 8, 10]` (피벗 `3`보다 큰 값들)
- **재귀 호출**:
  ```python
  quick_sort([1, 2, 1]) + [3] + quick_sort([6, 8, 10])
  ```

---

## 2단계: `quick_sort([1, 2, 1])` 호출
입력 배열: `[1, 2, 1]`

- **피벗**: `1` (첫 번째 요소)
- **분할**:
  - `left = [1]` (피벗 `1`보다 작거나 같은 값들)
  - `right = [2]` (피벗 `1`보다 큰 값들)
- **재귀 호출**:
  ```python
  quick_sort([1]) + [1] + quick_sort([2])
  ```

### 결과:
- `quick_sort([1])` → `[1]` (종료 조건: 길이가 1 이하)
- `quick_sort([2])` → `[2]` (종료 조건: 길이가 1 이하)

최종 결과: `[1, 1, 2]`

---

## 3단계: `quick_sort([6, 8, 10])` 호출
입력 배열: `[6, 8, 10]`

- **피벗**: `6` (첫 번째 요소)
- **분할**:
  - `left = []` (피벗 `6`보다 작거나 같은 값들, 없음)
  - `right = [8, 10]` (피벗 `6`보다 큰 값들)
- **재귀 호출**:
  ```python
  quick_sort([]) + [6] + quick_sort([8, 10])
  ```

### 결과:
- `quick_sort([])` → `[]` (종료 조건: 길이가 1 이하)
- `quick_sort([8, 10])`:
  - **피벗**: `8`
  - **분할**:
    - `left = []`, `right = [10]`
    - 결과: `[8, 10]`

최종 결과: `[6, 8, 10]`

---

## 4단계: 병합
1. `quick_sort([1, 2, 1])`의 결과: `[1, 1, 2]`
2. `quick_sort([6, 8, 10])`의 결과: `[6, 8, 10]`
3. 최종 병합:
   ```python
   [1, 1, 2] + [3] + [6, 8, 10] = [1, 1, 2, 3, 6, 8, 10]
   ```

---

## 최종 결과
정렬된 리스트:  
`[1, 1, 2, 3, 6, 8, 10]`
