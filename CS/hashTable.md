# Hash Table

### 해시 테이블(Hash Table) 알고리즘 개요  
해시 테이블은 **키(key)와 값(value)의 쌍을 저장하는 자료 구조**로, **빠른 검색, 삽입, 삭제**를 가능하게 하는 알고리즘입니다. 보통 **해시 함수(Hash Function)** 를 사용하여 키를 특정한 주소(인덱스)로 변환하고, 이를 기반으로 데이터를 저장하고 검색합니다.

---

## 1. 해시 테이블의 기본 구조  

해시 테이블은 배열과 연결 리스트를 조합하여 구성됩니다.  
각 데이터는 **(키, 값) 쌍**으로 저장되며, 키를 해시 함수에 입력하면 배열의 특정 인덱스를 얻습니다.

```
Key → Hash Function → Index → 저장된 값(Value)
```

예를 들어, 아래와 같은 데이터를 저장한다고 가정합시다.  

| Key   | Value      |
|-------|-----------|
| "Alice"  | 25  |
| "Bob"    | 30  |
| "Charlie"| 35  |

이를 배열 형태로 저장할 때, 각 키를 해시 함수로 변환하여 특정 인덱스에 저장합니다.

```
해시 함수 적용:
hash("Alice")   → 2  
hash("Bob")     → 5  
hash("Charlie") → 8  

해시 테이블:
Index | Data
------------------
0     | null
1     | null
2     | ("Alice", 25)
3     | null
4     | null
5     | ("Bob", 30)
6     | null
7     | null
8     | ("Charlie", 35)
```

---

## 2. 해시 함수(Hash Function)  

해시 함수는 **임의의 크기를 가진 키를 고정된 크기의 값(해시 값)으로 변환하는 함수**입니다.  
좋은 해시 함수는 다음과 같은 특징을 가져야 합니다.

1. **빠르게 계산 가능해야 함**  
2. **동일한 키는 항상 동일한 해시 값을 가져야 함 (Deterministic)**  
3. **서로 다른 키는 가능한 한 서로 다른 해시 값을 가져야 함 (충돌 최소화)**  
4. **균등한 분포를 가져야 함 (데이터가 특정 인덱스에 몰리지 않도록 분산해야 함)**  

### (예시) 간단한 해시 함수  
간단한 해시 함수의 예제로 문자열 키의 ASCII 값을 더하고, 배열 크기로 나눈 나머지를 인덱스로 변환하는 방식이 있습니다.

```java
public int simpleHash(String key, int tableSize) {
    int hashValue = 0;
    for (char ch : key.toCharArray()) {
        hashValue += ch;  // 각 문자 ASCII 값 합산
    }
    return hashValue % tableSize;  // 배열 크기로 나눈 나머지를 인덱스로 사용
}
```

예를 들어, `"Bob"`을 입력하면:  
`'B' (66) + 'o' (111) + 'b' (98) = 275`  
`275 % 10 (테이블 크기) = 5`  
즉, `"Bob"`은 **배열의 5번 인덱스에 저장**됩니다.

---

## 3. 충돌 해결 방법 (Collision Resolution)  

해시 테이블의 핵심 문제 중 하나는 **충돌(Collision)** 입니다.  
즉, **서로 다른 키가 같은 해시 값(인덱스)을 가질 때** 이를 어떻게 해결할지가 중요합니다.  

### ① 체이닝(Chaining) 방식  
배열의 각 인덱스가 **연결 리스트(Linked List)** 를 가리키도록 하는 방식입니다.  
같은 인덱스에 여러 개의 값이 저장되면, 해당 인덱스에서 연결 리스트로 관리합니다.

#### 예제
1. `"Alice"`와 `"David"`가 해시 함수에 의해 같은 인덱스 `2`를 가졌다면, 아래처럼 저장됩니다.

```
Index | Data
-----------------
2     | ("Alice", 25) → ("David", 40)
```

2. 데이터를 찾을 때는, 해당 인덱스의 리스트를 탐색하여 원하는 키를 찾습니다.

> **장점:** 충돌이 발생해도 유연하게 처리 가능  
> **단점:** 연결 리스트가 길어지면 검색 속도가 느려질 수 있음 (최악의 경우 O(n))

---

### ② 개방 주소법(Open Addressing) 방식  
충돌이 발생하면 **해시 테이블 내의 다른 빈 공간을 찾아 저장하는 방식**입니다.

1. **선형 탐사(Linear Probing)**  
   - 충돌 발생 시, **다음(인접) 인덱스를 차례로 탐색**하여 빈 공간에 저장  
   - 예: `"Alice"`와 `"David"`가 같은 인덱스를 가지면, `"David"`는 다음 빈 공간에 저장

```
Index | Data
-----------------
2     | ("Alice", 25)
3     | ("David", 40)  ← 빈 공간을 찾아 저장
```

2. **이차 탐사(Quadratic Probing)**  
   - 선형 탐사는 클러스터링 문제가 발생할 수 있으므로, i² (제곱) 단위로 탐색 범위를 늘려서 저장  

3. **이중 해싱(Double Hashing)**  
   - 충돌 발생 시, **다른 해시 함수를 사용하여 새로운 위치를 찾음**

> **장점:** 추가적인 메모리 사용이 없음  
> **단점:** 해시 테이블이 꽉 차면 충돌이 심각해질 수 있음  

---

## 4. 해시 테이블의 시간 복잡도  

| 연산  | 평균 시간 복잡도 | 최악의 경우 (충돌 많을 때) |
|-------|--------------|-----------------|
| 검색  | O(1)        | O(n)            |
| 삽입  | O(1)        | O(n)            |
| 삭제  | O(1)        | O(n)            |

- **충돌이 적으면 O(1)**
- **충돌이 많으면 탐색이 필요하므로 최악의 경우 O(n)**

---

## 5. 해시 테이블의 활용 사례  
해시 테이블은 빠른 검색 속도 때문에 다양한 곳에서 활용됩니다.

1. **데이터베이스 인덱싱** → 검색 속도 최적화  
2. **캐싱(Cache) 시스템** → 최근 사용한 데이터 저장  
3. **중복 검사 (Duplicate Checking)** → 빠른 비교 가능  
4. **컴파일러 심볼 테이블 (Symbol Table)** → 변수 및 함수 관리  
5. **라우팅 테이블 (Routing Table)** → IP 주소 저장 및 탐색  

---

## 6. 자바의 해시 테이블 구현  

자바에서는 `HashMap` 클래스를 통해 해시 테이블을 쉽게 사용할 수 있습니다.

```java
import java.util.HashMap;

public class HashTableExample {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();

        // 데이터 삽입
        map.put("Alice", 25);
        map.put("Bob", 30);
        map.put("Charlie", 35);

        // 데이터 검색
        System.out.println("Alice의 나이: " + map.get("Alice"));  // 25

        // 데이터 삭제
        map.remove("Bob");
    }
}
```

---

## 7. 결론  
- 해시 테이블은 **키-값 저장 구조**를 사용하여 빠른 검색/삽입/삭제를 지원  
- **해시 함수**를 통해 데이터를 인덱스로 변환하여 저장  
- **충돌(Collision) 해결 방식**으로 **체이닝(Chaining)** 과 **개방 주소법(Open Addressing)** 을 사용  
- 자바에서는 `HashMap`, `Hashtable` 등의 클래스를 활용하여 구현 가능  

### ✅ **해시 테이블은 O(1) 성능으로 데이터를 빠르게 찾고 저장해야 하는 경우에 최적화된 자료구조입니다!**