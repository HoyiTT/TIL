# Array vs ArrayList vs LinkedList

## Array

### 정의
- 배열은 크기가 고정되어 있어 크기를 변경할 수 없다.

### 특징
- 요소가 메모리 상에 연속적으로 배치된다.
- 크기가 고정되어 생성 시 메모리 크기를 명시해여 한다.
- 데이터 접근 속도가 빠르다.(인덱스를 활용한 O(1) 시간복잡도)
- 데이터 삽입, 삭제가 비효율 적이다.(중간 위치 삽입시 O(n) 시간복잡도)

### 주요 연산
- 삽입
    맨 뒤에 삽입: O(1)
    중간/앞쪽에 삽입: O(n) (뒤 요소들을 이동해야 함)
- 삭제
    맨 뒤의 요소 삭제: O(1)
    중간/앞쪽의 요소 삭제: O(n) (뒤 요소들을 이동해야 함)
- 검색
    인덱스를 통한 접근: O(1)
    값 검색(탐색): O(n)

## ArrayList

### 정의
- 크기가 고정된 배열을 확장하여, 요소의 수가 동적으로 변할 수 있는 배열 기반 자료구조.

### 특징

- 동적 크기 조정 : 크기가 초과되면 새로운 배열을 생성하고 기존 요소를 복사
- 삽입 삭제시 Array의 단점을 그대로 가짐


#### 메모리 동적 확장 방식
- 초기 배열 크기는 보통 작은 값으로 시작
- 배열이 가득 차면 그키를 1.5 ~ 2배로 확장하고 기존 요소를 새로운 배열로 복사

### 주요 연산

- 삽입
    맨 뒤에 삽입: O(1) (크기 초과 시 O(n) 복사 비용 포함)
    중간/앞쪽에 삽입: O(n)
- 삭제
    맨 뒤의 요소 삭제: O(1)
    중간/앞쪽의 요소 삭제: O(n)
- 검색
    인덱스를 통한 접근: O(1)
    값 검색(탐색): O(n)


## LinkedList

### 정의
- 각 요소(Node)가 데이터와 포인터(다음 요소의 주소)로 구성된 자료구조

### 특징
- 크기가 동적이며, 메모리의 임의 위치에 요소를 저장 가능
- 연속적인 메로리를 요구하지 않음
- 삽입, 삭제가 빠르지만, 인덱스 접근 속도가 느림

#### 노드 기반의 메모리 구조
- 각 노드는 데이터와 다음 노드를 가리키는 포인터로 구성
- 마지막 노드의 포인터는 NULL을 가리킴

### 주요 연산
- 삽입
    맨 앞/맨 뒤 삽입: O(1) (포인터만 수정)
    중간 삽입: O(n) (삽입 위치 탐색 필요)
- 삭제
    맨 앞/맨 뒤 삭제: O(1) (포인터만 수정)
    중간 삭제: O(n) (삭제 위치 탐색 필요)
- 검색
    값 검색(탐색): O(n) (인덱스를 통한 접근 불가)


## 사용 사례

### Array

데이터의 크기가 고정적이고 변경되지 않는 경우.

빠른 접근이 필요한 경우 (인덱스를 통해 O(1)로 접근 가능).


고정된 크기의 학생 점수 목록
월별 매출 데이터를 저장
게임의 정해진 크기의 보드나 맵 (예: 체스판)
선택 기준
데이터 크기가 사전에 명확히 정의되어 있는 경우.
데이터의 삽입/삭제가 거의 없고, 주로 읽기와 검색이 필요한 경우.

### ArrayList

데이터의 크기가 가변적이고 동적으로 변하는 경우.
빈번한 검색과 추가 작업이 필요한 경우.


사용자가 추가 및 삭제 가능한 장바구니 시스템
실시간으로 추가/삭제되는 메시지 로그 저장
동적 필터링 및 검색이 필요한 검색 결과 목록

선택 기준

데이터 크기를 사전에 알 수 없으며, 동적 크기 조정이 필요한 경우.
삽입/삭제보다는 읽기와 탐색이 중요한 경우.
메모리 공간을 비교적 효율적으로 관리하고자 할 때.

### LinkedList

데이터 크기가 자주 변동하고 삽입/삭제 작업이 빈번한 경우.
요소의 위치를 유지하면서 삽입/삭제를 자주 수행해야 하는 경우.

프로세스 관리(스케줄러 큐)
Undo/Redo 기능이 있는 편집기
이중 연결 리스트로 구현한 양방향 탐색 가능한 데이터 구조

선택 기준

삽입/삭제 작업이 빈번하고, 작업 시 데이터의 이동을 최소화하고자 할 때.
메모리 크기가 유동적이거나, 요소 간의 연결 관계를 관리해야 하는 경우.