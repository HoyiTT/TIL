컴퓨터 아키텍처는 컴퓨터의 성능과 효율성에 큰 영향을 미칩니다. RISC(Reduced Instruction Set Computer)와 CISC(Complex Instruction Set Computer)는 두 가지 주요 명령어 집합 아키텍처입니다. 이 글에서는 RISC와 CISC의 기본 개념, 특징, 장단점, 그리고 현대 컴퓨터에서 이 두 아키텍처가 어떻게 적용되고 있는지를 살펴보겠습니다.

1. 기본 개념
1.1 CISC (Complex Instruction Set Computer)
정의: CISC는 복잡한 명령어 세트를 사용하여 하나의 명령어로 여러 작업을 수행할 수 있는 아키텍처입니다.
특징:
명령어 집합: 다양한 명령어가 제공되며, 각 명령어는 여러 개의 마이크로 코드로 내부적으로 처리됩니다.
가변 길이 명령어: 명령어의 길이가 다를 수 있습니다.
복잡한 명령어: 하나의 명령어로 복잡한 연산을 수행할 수 있습니다.
1.2 RISC (Reduced Instruction Set Computer)
정의: RISC는 간단하고 일관된 명령어 세트를 사용하여 명령어를 빠르게 처리할 수 있는 아키텍처입니다.
특징:
명령어 집합: 간단하고 고정 길이의 명령어를 사용합니다.
단순한 명령어: 명령어 하나가 하나의 마이크로 코드로 매핑됩니다.
파이프라이닝: 명령어 처리 과정이 간단하여 파이프라이닝과 병렬 처리가 용이합니다.
2. 기술적 차이
2.1 명령어 처리
CISC: 복잡한 명령어가 내부적으로 여러 단계의 마이크로 코드를 사용하여 처리됩니다. 이를 통해 복잡한 작업을 하나의 명령어로 수행할 수 있지만, 명령어 디코딩과 실행이 복잡해질 수 있습니다.
RISC: 단순한 명령어가 고정된 길이로 처리되어, 디코딩과 실행이 빠르고 효율적입니다. 각 명령어는 하나의 단계로 처리됩니다.
2.2 메모리 사용
CISC: 복잡한 명령어를 사용하여 명령어 수를 줄이고, 메모리 사용을 최소화합니다. 그러나 내부적으로는 여러 단계의 마이크로 코드가 필요합니다.
RISC: 명령어 수는 상대적으로 많지만, 각 명령어가 단순하고 일관되므로, 메모리 접근이 효율적입니다.
2.3 성능
CISC: 복잡한 명령어 세트로 인해 초기 성능이 좋을 수 있지만, 명령어 디코딩이 복잡하여 성능 저하를 일으킬 수 있습니다.
RISC: 간단한 명령어 구조로 인해 빠른 명령어 실행과 효율적인 파이프라이닝이 가능합니다.
3. 장단점 비교
3.1 CISC의 장점
프로그램 크기: 복잡한 명령어로 프로그램을 더 짧게 작성할 수 있습니다.
프로그래밍 용이성: 복잡한 연산을 단순한 명령어로 수행할 수 있어 프로그래밍이 용이합니다.
3.2 CISC의 단점
디코딩 복잡성: 복잡한 명령어 세트로 인해 명령어 디코딩과 실행이 복잡합니다.
전력 소비: 복잡한 명령어 처리로 인해 전력 소비가 증가할 수 있습니다.
3.3 RISC의 장점
성능: 간단한 명령어 세트로 인해 빠른 명령어 실행과 효율적인 파이프라이닝이 가능합니다.
전력 효율성: 간단한 명령어로 인해 전력 소비가 낮습니다.
3.4 RISC의 단점
프로그램 크기: 단순한 명령어 세트로 인해 프로그램의 명령어 수가 증가할 수 있습니다.
프로그래밍 복잡성: 복잡한 작업을 여러 개의 단순한 명령어로 나누어야 할 수 있습니다.
4. 현대의 응용
4.1 CISC의 현대적 적용
x86 아키텍처: 인텔과 AMD의 프로세서에서 사용되며, 강력한 호환성과 성능을 제공합니다.
소프트웨어 호환성: 다양한 소프트웨어와의 호환성 문제를 해결할 수 있습니다.
4.2 RISC의 현대적 적용
ARM 아키텍처: 모바일 기기, IoT 기기, 최신 애플 제품 등에서 사용되며, 뛰어난 전력 효율성과 성능을 제공합니다.
서버와 클라우드: 최근에는 서버와 클라우드 환경에서도 RISC 아키텍처가 채택되고 있습니다.
5. 최근 RISC가 떠오르는 이유
5.1 RISC가 나중에 나온 이유

당연히 RISC가 먼저 개발되었을 줄 알았지만 CISC가 먼저 개발되었습니다.

CISC가 먼저 개발된 이유는, 초기의 기술적 제약과 당시의 필요성에서 기인합니다.

초기 컴퓨터 개발의 목적: 1960~70년대에는 메모리와 하드웨어의 성능이 매우 제한적이었습니다. 당시 컴퓨터 설계자들은 메모리의 절약과 프로그래머의 편의성을 최우선으로 고려했습니다. 그래서 한 번에 여러 작업을 수행할 수 있는 복잡한 명령어 세트를 개발하는 것이 더 효율적이었습니다. 복잡한 명령어를 제공함으로써 더 적은 명령어로 프로그램을 작성할 수 있었고, 이는 메모리를 절약할 수 있었습니다. 즉, CISC는 당시 하드웨어의 제약을 소프트웨어적으로 해결하려는 시도였던 것입니다.
마이크로 코드의 역할: CISC의 복잡한 명령어는 CPU 내부에서 마이크로 코드로 번역됩니다. 마이크로 코드는 CPU 내부에서 실제로 실행되는 일련의 간단한 명령어들이며, 이는 CPU가 복잡한 명령어를 처리하는 방식입니다. 이 과정이 비교적 느리지만, CISC 명령어 하나로 여러 작업을 동시에 수행할 수 있으므로 프로그램의 명령어 수는 줄어듭니다. 결과적으로 메모리 사용이 줄어드는 이점이 있었고, 당시 메모리가 비쌌기 때문에 이는 큰 장점이었습니다.
기술적 한계: RISC와 같은 단순한 명령어 기반 설계는 CPU가 매우 빠르게 작동할 수 있는 장점이 있습니다. 하지만 RISC 아키텍처는 당시에는 상대적으로 구현하기 어려웠습니다. RISC 구조가 최대 성능을 발휘하려면 고속의 메모리 및 데이터 전송 기술이 필요했기 때문입니다. 그러나 이러한 기술은 나중에 와서야 발전했기 때문에, 초기에는 CISC 구조가 더 현실적이었습니다.

5. 최근 RISC가 떠오르는 이유
5.1 RISC가 나중에 나온 이유

당연히 RISC가 먼저 개발되었을 줄 알았지만 CISC가 먼저 개발되었습니다.

CISC가 먼저 개발된 이유는, 초기의 기술적 제약과 당시의 필요성에서 기인합니다.

초기 컴퓨터 개발의 목적: 1960~70년대에는 메모리와 하드웨어의 성능이 매우 제한적이었습니다. 당시 컴퓨터 설계자들은 메모리의 절약과 프로그래머의 편의성을 최우선으로 고려했습니다. 그래서 한 번에 여러 작업을 수행할 수 있는 복잡한 명령어 세트를 개발하는 것이 더 효율적이었습니다. 복잡한 명령어를 제공함으로써 더 적은 명령어로 프로그램을 작성할 수 있었고, 이는 메모리를 절약할 수 있었습니다. 즉, CISC는 당시 하드웨어의 제약을 소프트웨어적으로 해결하려는 시도였던 것입니다.
마이크로 코드의 역할: CISC의 복잡한 명령어는 CPU 내부에서 마이크로 코드로 번역됩니다. 마이크로 코드는 CPU 내부에서 실제로 실행되는 일련의 간단한 명령어들이며, 이는 CPU가 복잡한 명령어를 처리하는 방식입니다. 이 과정이 비교적 느리지만, CISC 명령어 하나로 여러 작업을 동시에 수행할 수 있으므로 프로그램의 명령어 수는 줄어듭니다. 결과적으로 메모리 사용이 줄어드는 이점이 있었고, 당시 메모리가 비쌌기 때문에 이는 큰 장점이었습니다.
기술적 한계: RISC와 같은 단순한 명령어 기반 설계는 CPU가 매우 빠르게 작동할 수 있는 장점이 있습니다. 하지만 RISC 아키텍처는 당시에는 상대적으로 구현하기 어려웠습니다. RISC 구조가 최대 성능을 발휘하려면 고속의 메모리 및 데이터 전송 기술이 필요했기 때문입니다. 그러나 이러한 기술은 나중에 와서야 발전했기 때문에, 초기에는 CISC 구조가 더 현실적이었습니다.
RISC가 나중에 나온 이유는?
기술 발전: 시간이 지나면서, CPU와 메모리의 성능이 크게 향상되었습니다. 특히, 캐시 메모리와 고속 메모리 기술이 발전하면서, 복잡한 명령어가 아닌 단순하고 빠른 명령어로도 효율적인 처리가 가능해졌습니다. RISC는 이 기술 발전의 수혜를 받았고, 메모리 비용이 낮아지고 성능이 향상되면서 RISC 구조가 주목받기 시작했습니다.
병렬 처리와 최적화의 가능성: RISC는 복잡한 명령어를 여러 개의 간단한 명령어로 나누기 때문에, 현대 CPU의 파이프라이닝이나 병렬 처리와 같은 기법에서 유리한 구조를 가지고 있습니다. 이는 RISC가 성능 향상을 위해 적합한 구조라는 것을 보여줬고, 특히 전력 효율성이 중요한 모바일 기기에서 RISC 기반의 ARM 아키텍처가 널리 사용되게 된 배경이기도 합니다.
마이크로 코드와 명령어 디코딩의 부담: CISC 아키텍처는 복잡한 명령어를 실행하기 위해 내부적으로 여러 마이크로 코드를 사용합니다. 이는 명령어를 디코딩하는 데 시간과 자원이 더 많이 소모되는 단점이 있습니다. 반면, RISC는 명령어 자체가 간단하고 고정적이어서 디코딩이 빠르고, 파이프라이닝과 같은 고속 처리 기술에 최적화된 구조를 가질 수 있었습니다.
5.2 메모리 비용 및 효율성의 향상

1. 복잡한 명령어로 메모리 사용 감소
CISC 구조의 핵심은 복잡한 작업을 하나의 명령어로 처리할 수 있다는 점입니다. 예를 들어, 메모리에서 데이터를 읽고, 연산을 수행한 후, 다시 메모리에 저장하는 작업을 CISC에서는 하나의 명령어로 처리할 수 있습니다. 반면에, RISC에서는 이러한 작업을 여러 개의 단순한 명령어로 나누어야 합니다.

즉, CISC 명령어는 다수의 마이크로 명령어를 내부적으로 실행하지만, 외부에서 보이는 명령어 수는 매우 적어집니다. 프로그램이 더 적은 수의 명령어로 작성되므로, 전체 프로그램 크기가 줄어들게 됩니다. 당시의 상황에서는 메모리 용량이 제한적이고, 메모리 비용이 매우 높았기 때문에, 적은 명령어로 프로그램을 작성하는 것이 메모리 사용 효율성을 높이는 데 중요한 역할을 했습니다.

예시:
CISC 명령어: MOV AX, [MEM], ADD AX, BX, MOV [MEM], AX (하나의 복잡한 명령어로 처리)
RISC 명령어: LOAD R1, MEM, ADD R2, R1, R3, STORE MEM, R2 (3개의 단순한 명령어)
이처럼 CISC에서는 복잡한 동작을 하나의 명령어로 처리하기 때문에, 메모리 내에 저장되는 명령어 수가 줄어들게 됩니다. 따라서 프로그램 크기가 작아지고, 이는 곧 메모리 절감으로 이어집니다.

2. 마이크로 코드의 내부 처리
CISC 구조에서는 복잡한 명령어가 내부적으로 여러 개의 마이크로 코드로 분해되어 실행됩니다. 그러나 이 마이크로 코드는 CPU 내부에 저장되어 실행되며, 외부 메모리에는 영향을 미치지 않습니다. 즉, 복잡한 명령어는 외부 프로그램 코드에서는 단 하나의 명령어로 표현되지만, CPU 내부에서는 그 명령어가 여러 마이크로 코드로 변환되어 실행됩니다. 이는 CPU가 내부적으로 처리하는 부분이므로, 외부 메모리의 사용량을 증가시키지 않습니다.

마이크로 코드 처리 과정:
ADD [MEM1], [MEM2]라는 명령어가 있을 때, 이 명령어는 CPU 내부에서 여러 단계로 분해됩니다.
메모리 1의 값을 로드
메모리 2의 값을 로드
두 값을 더함
결과를 다시 메모리 1에 저장
이 모든 과정이 하나의 명령어로 처리되므로, 프로그램의 명령어 수가 적어지고, 프로그램 크기가 작아집니다.

3. 명령어 크기 및 압축
CISC의 또 다른 특징은 가변 길이 명령어입니다. 즉, CISC 명령어는 1바이트에서 10바이트 이상의 크기를 가질 수 있으며, 필요에 따라 명령어의 길이를 효율적으로 사용할 수 있습니다. 간단한 명령어는 짧은 길이로 처리하고, 복잡한 명령어는 더 많은 바이트를 사용하여 표현할 수 있습니다.

이 가변 길이 명령어는 당시 제한된 메모리 공간을 최대한 활용할 수 있는 방법 중 하나였습니다. 프로그램에서 필요한 연산에 따라 명령어의 크기가 달라지기 때문에, 짧은 명령어로 표현할 수 있는 경우에는 메모리를 절약하게 됩니다.

반면, RISC는 고정 길이 명령어를 사용하므로, 항상 일정한 크기의 명령어를 사용해야 합니다. 즉, 간단한 작업이라도 고정된 크기의 명령어로 표현해야 하므로, 상대적으로 메모리 사용량이 증가할 수 있습니다.

4. 메모리 접근 최소화
CISC 아키텍처는 복잡한 명령어를 제공함으로써, 여러 작업을 하나의 명령어로 묶어서 처리할 수 있습니다. 이로 인해 메모리 접근 횟수가 줄어듭니다. 메모리 접근은 시스템에서 중요한 자원 소모 요소 중 하나인데, CISC 명령어는 메모리에 여러 번 접근하지 않고 한 번에 데이터를 로드하고 처리할 수 있습니다. 이는 메모리 대역폭을 아끼고, 메모리와의 통신 횟수를 줄임으로써 전체 시스템의 메모리 사용 효율성을 높이는 데 기여합니다.

 

즉, CISC는 마이크로 코드 여러개를 조합 -> 하나의 CPU 명령어 -> 메모리 접근 1번

같은 행위를 하는 

RISC 명령어 -> 여러개의 CPU 명령어 -> 경우에 따라 메모리 접근 1번이상

=> 메모리 효율성을 위해 CISC가 사용되게 된것!

하지만 현대에는 기술의 발달로 RISC가 더 효율적인 시대가 도래함!

결론
CISC와 RISC는 각기 다른 장점과 단점을 가진 두 가지 주요 컴퓨터 아키텍처입니다. CISC는 복잡한 명령어를 통해 메모리 사용을 절약하며, 프로그래밍의 편리성을 제공합니다. 반면, RISC는 간단한 명령어 구조를 통해 빠르고 효율적인 성능을 구현합니다. 현대의 다양한 요구와 기술 발전에 따라, 두 아키텍처는 각각의 강점을 살려서 다양한 분야에서 활용되고 있습니다.

